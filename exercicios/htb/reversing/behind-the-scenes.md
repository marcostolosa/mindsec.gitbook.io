---
description: Reversing Challenge - Very Easy
---

# Behind the Scenes

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

## üèÜ HACKTHEBOX - BEHINDTHESCENES WRITEUP COMPLETO

> **"Algumas vezes a melhor maneira de derrotar o anti-debug √© nunca debuggar"**

***

### üéØ OBJETIVO

Extrair a flag escondida de um bin√°rio ELF64 (protegido por t√©cnicas anti-debug avan√ßadas).

***

### üîç RECONHECIMENTO INICIAL

#### Verifica√ß√£o B√°sica do Arquivo

```bash
# Identificar tipo do arquivo
$ file behindthescenes
behindthescenes: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=c20c22d2fb4b38ad37f5b2e5adf8b5b1f3f4e3d5, for GNU/Linux 3.2.0, not stripped

# Verificar permiss√µes e tamanho
$ ls -la behindthescenes
-rwxr-xr-x 1 user user 14856 Dec 15 10:30 behindthescenes

# Verificar se h√° s√≠mbolos de debug
$ readelf -S behindthescenes | grep debug
# Resultado: Nenhuma se√ß√£o de debug (stripped parcialmente)

# Testar execu√ß√£o b√°sica
$ ./behindthescenes
./challenge <password>
```

**üìä Primeiras Observa√ß√µes:**

* Bin√°rio ELF64 din√¢mico padr√£o
* N√£o stripped (s√≠mbolos dispon√≠veis)
* Requer argumento de senha
* Mensagem de uso limpa

#### An√°lise de Strings

```bash
# Extrair strings leg√≠veis
$ strings behindthescenes
/lib64/ld-linux-x86-64.so.2
libc.so.6
strncmp          # ‚Üê CR√çTICO: Compara√ß√£o de strings
puts
__stack_chk_fail
printf           # ‚Üê CR√çTICO: Output
strlen
sigemptyset      # ‚Üê SUSPEITO: Signal handling
memset
sigaction        # ‚Üê RED FLAG: Anti-debug
__cxa_finalize
__libc_start_main
./challenge <password>
GLIBC_2.4
GLIBC_2.2.5

# Extrair strings com offset para localiza√ß√£o
$ strings -o behindthescenes | grep -E "(password|flag|htb|challenge)"
    8196 ./challenge <password>
```

**üö® Red Flags Identificados:**

* `sigaction` + `sigemptyset` = Manipula√ß√£o de signals
* `strncmp` = Compara√ß√£o de senha
* `printf` = Output de resultado
* Nenhuma string √≥bvia de senha

#### An√°lise de Imports/Exports

```bash
# Verificar s√≠mbolos importados
$ objdump -T behindthescenes
DYNAMIC SYMBOL TABLE:
0000000000000000      DF *UND*  0000000000000000  GLIBC_2.2.5 strncmp
0000000000000000      DF *UND*  0000000000000000  GLIBC_2.2.5 puts
0000000000000000      DF *UND*  0000000000000000  GLIBC_2.4   __stack_chk_fail
0000000000000000      DF *UND*  0000000000000000  GLIBC_2.2.5 printf
0000000000000000      DF *UND*  0000000000000000  GLIBC_2.2.5 strlen
0000000000000000      DF *UND*  0000000000000000  GLIBC_2.2.5 sigemptyset
0000000000000000      DF *UND*  0000000000000000  GLIBC_2.2.5 memset
0000000000000000      DF *UND*  0000000000000000  GLIBC_2.2.5 sigaction

# Verificar s√≠mbolos exportados
$ nm behindthescenes | grep -E "(main|sigaction|handler)"
0000000000101261 T main
0000000000101229 t sigill_sigaction  # ‚Üê FUN√á√ÉO SUSPEITA!
```

**üéØ An√°lise dos Imports:**

* Signal handling √© confirmado (`sigaction`, `sigemptyset`)
* String processing presente (`strncmp`, `strlen`)
* Output capability (`printf`, `puts`)
* Stack protection ativa (`__stack_chk_fail`)

***

### üß™ TESTE DIN√ÇMICO INICIAL

#### Testes de Execu√ß√£o

```bash
# Teste sem argumentos
$ ./behindthescenes
./challenge <password>

# Teste com senha simples
$ ./behindthescenes test
# Resultado: Nada (sil√™ncio total)

# Teste com senha comum
$ ./behindthescenes password
# Resultado: Nada

# Teste com buffer overflow
$ ./behindthescenes $(python3 -c "print('A'*100)")
# Resultado: Nada (sem crash)

# Teste com caracteres especiais
$ ./behindthescenes "!@#$%^&*()"
# Resultado: Nada
```

**üß† Observa√ß√£o Cr√≠tica:** O programa tem **falha silenciosa** - n√£o d√° feedback de erro nem sucesso. Isso √© extremamente suspeito e indica prote√ß√£o.

#### Verifica√ß√£o de Prote√ß√µes

```bash
# Verificar prote√ß√µes de bin√°rio
$ checksec --file=behindthescenes
RELRO           : Full RELRO
Stack           : Canary found
NX              : NX enabled
PIE             : PIE enabled
RUNPATH         : No RUNPATH
Symbols         : 73 Symbols

# Verificar se h√° anti-debug √≥bvio
$ ltrace ./behindthescenes test 2>&1 | head -10
sigaction(SIGILL, { 0x101229, [], SA_SIGINFO }, NULL) = 0  # ‚Üê SIGILL!
# Processo para aqui...

# Verificar system calls
$ strace -e trace=signal ./behindthescenes test 2>&1
rt_sigaction(SIGILL, {sa_handler=0x555555555229, sa_mask=[], sa_flags=SA_SIGINFO}, NULL, 8) = 0
--- SIGILL {si_signo=SIGILL, si_code=ILL_ILLOPN, si_addr=0x555555555274} ---
# SIGILL disparado!
```

<figure><img src="../../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

**üî• DESCOBERTA CRUCIAL:**

* `sigaction(SIGILL, ...)` = Registra handler para instru√ß√£o ilegal
* `SIGILL` √© disparado durante execu√ß√£o
* Isso indica **t√©cnica anti-debug UD2**!

***

### üõ°Ô∏è IDENTIFICA√á√ÉO DA T√âCNICA ANTI-DEBUG

#### An√°lise Est√°tica com Ghidra

**Setup do Ghidra**

```bash
# Abrir Ghidra
$ ghidra

# Processo no Ghidra:
# 1. File ‚Üí Import File ‚Üí behindthescenes
# 2. Analysis ‚Üí Auto Analyze ‚Üí marcar todas op√ß√µes
# 3. Aguardar an√°lise completa
```

**An√°lise da Fun√ß√£o Main**

Navegando para a fun√ß√£o `main` no Ghidra:

```c
void main(void) {
  code *pcVar1;
  long in_FS_OFFSET;
  sigaction local_a8;
  undefined8 local_10;
  
  // Stack canary setup
  local_10 = *(undefined8 *)(in_FS_OFFSET + 0x28);
  
  // Limpa estrutura sigaction
  memset(&local_a8,0,0x98);
  sigemptyset(&local_a8.sa_mask);
  
  // Configura handler personalizado
  local_a8.__sigaction_handler.sa_handler = sigill_sigaction;
  local_a8.sa_flags = 4;  // SA_SIGINFO
  
  // Registra handler para SIGILL (signal 4)
  sigaction(4,&local_a8,(sigaction *)0x0);
  
  // LINHA CR√çTICA: Executa instru√ß√£o ilegal
  pcVar1 = (code *)invalidInstructionException();
  (*pcVar1)();
}
```

**An√°lise do Signal Handler**

```c
void sigill_sigaction(undefined8 param_1,undefined8 param_2,long param_3) {
  // Incrementa RIP em 2 bytes para pular instru√ß√£o UD2
  *(long *)(param_3 + 0xa8) = *(long *)(param_3 + 0xa8) + 2;
  return;
}
```

**üéØ Compreens√£o da T√©cnica:**

1. **Setup**: Registra handler customizado para SIGILL
2. **Trigger**: Executa instru√ß√£o UD2 (illegal instruction)
3. **Bypass**: Handler incrementa RIP+2 para pular UD2
4. **Execution**: C√≥digo real executa ap√≥s a instru√ß√£o ilegal

#### Procurando a Instru√ß√£o UD2

```bash
# Buscar bytes UD2 (0x0F 0x0B) no bin√°rio
$ hexdump -C behindthescenes | grep "0f 0b"
00001270  48 83 c4 08 c3 66 0f 1f  44 00 00 0f 0b 48 83 ec  |H....f..D...H..|

# Confirmar localiza√ß√£o com objdump
$ objdump -d behindthescenes | grep -A5 -B5 "ud2"
0000000000001272:	0f 0b                	ud2    
0000000000001274:	48 83 ec 08          	sub    $0x8,%rsp
# C√≥digo continua ap√≥s UD2!
```

<figure><img src="../../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

**üí° Insight Crucial:** O c√≥digo real est√° localizado **imediatamente ap√≥s** a instru√ß√£o UD2 em `0x1274`!

***

### üé™ ESTRAT√âGIA DE BYPASS

Identificamos que √© uma t√©cnica anti-debug UD2. Temos v√°rias op√ß√µes:

#### Op√ß√£o 1: Bypass Din√¢mico (GDB)

#### Op√ß√£o 2: Patch do Bin√°rio

#### Op√ß√£o 3: An√°lise Est√°tica dos Dados (ESCOLHIDA!)

**Por que escolhi a Op√ß√£o 3:**

* Mais elegante e educativa
* N√£o requer execu√ß√£o do c√≥digo protegido
* Demonstra poder da an√°lise est√°tica

***

### üîç AN√ÅLISE EST√ÅTICA - DATA HUNTING

#### Examinando a Se√ß√£o .rodata

```bash
# Listar se√ß√µes do bin√°rio
$ readelf -S behindthescenes | grep rodata
  [16] .rodata           PROGBITS         0000000000102000  00002000
       0000000000000036  0000000000000000   A       0     0     1

# Dump da se√ß√£o .rodata
$ objdump -s -j .rodata behindthescenes
Contents of section .rodata:
 102000 01000200 2e2f6368 616c6c65 6e676520  ..../challenge 
 102010 3c706173 73776f72 643e0049 747a005f  <password>.Itz._
 102020 306e004c 795f0055 44320003 e204854  0n.Ly_.UD2......
 102030 425b2573 7d0a00                      HTB{%s}..

# Converter hex para ASCII para melhor visualiza√ß√£o
$ readelf -x .rodata behindthescenes
Hex dump of section '.rodata':
  0x00102000 01000200 2e2f6368 616c6c65 6e676520 ..../challenge 
  0x00102010 3c706173 73776f72 643e0049 747a005f <password>.Itz._
  0x00102020 306e004c 795f0055 44320003 e204854  0n.Ly_.UD2......
  0x00102030 425b2573 7d0a00                      HTB{%s}..
```

#### An√°lise Detalhada dos Dados

```bash
# Analisar endere√ßos espec√≠ficos
$ python3 -c "
data = bytes.fromhex('49747a005f306e004c795f0055443200')
strings = []
current = b''
for byte in data:
    if byte == 0:
        if current:
            strings.append(current.decode())
            current = b''
    else:
        current += bytes([byte])
if current:
    strings.append(current.decode())
print('Strings encontradas:', strings)
"
# Resultado: ['Itz', '_0n', 'Ly_', 'UD2']
```

**üî• DESCOBERTA DA SENHA!**

#### Reconstru√ß√£o da Senha

```bash
# Concatenar as partes encontradas
$ python3 -c "print('Itz' + '_0n' + 'Ly_' + 'UD2')"
Itz_0nLy_UD2

# Verificar format string HTB
$ python3 -c "print(bytes.fromhex('3e20485442257b73257d0a00').decode())"
> HTB{%s}
```

**üí° An√°lise da Senha:**

* **"Itz\_0nLy\_UD2"** = "It's only UD2"
* Refer√™ncia direta √† t√©cnica anti-debug usada!
* Format string `"> HTB{%s}"` confirma formato da flag

***

### ‚ö° TESTE DA SENHA DESCOBERTA

```bash
# Testar a senha encontrada
$ ./behindthescenes Itz_0nLy_UD2
> HTB{Itz_0nLy_UD2}
```

**üéâ SUCESSO! Flag capturada!**

***

### üß™ VALIDA√á√ÉO E TESTES ADICIONAIS

#### Verifica√ß√£o de Case Sensitivity

```bash
# Testar case incorreto
$ ./behindthescenes itz_0nly_ud2
# Resultado: Sil√™ncio (case sensitive confirmado)

# Testar varia√ß√µes
$ ./behindthescenes "Itz_0nLy_UD2 "
# Resultado: Sil√™ncio (espa√ßos extras n√£o aceitos)
```

#### An√°lise do Comportamento de Falha

```bash
# Testar senhas incorretas
$ ./behindthescenes wrong_password
# Resultado: Sa√≠da silenciosa

# Verificar se h√° diferentes tipos de erro
$ ./behindthescenes ""
# Resultado: Sa√≠da silenciosa (provavelmente argc check)
```

#### Trace da Execu√ß√£o Correta

```bash
# Verificar chamadas de sistema com senha correta
$ strace -e trace=write ./behindthescenes Itz_0nLy_UD2 2>&1
write(1, "> HTB{Itz_0nLy_UD2}\n", 18) = 18
# Confirmado: printf() √© chamado apenas com senha correta

# Verificar library calls
$ ltrace ./behindthescenes Itz_0nLy_UD2 2>&1
sigaction(SIGILL, { 0x101229, [], SA_SIGINFO }, NULL) = 0
strncmp("Itz_0nLy_UD2", "Itz_0nLy_UD2", 12) = 0  # ‚Üê COMPARA√á√ÉO!
printf("> HTB{%s}\n", "Itz_0nLy_UD2") = 18
```

**‚úÖ Confirma√ß√£o Final:**

* `strncmp()` compara nossa entrada com senha hardcoded
* `printf()` √© chamado apenas quando compara√ß√£o retorna 0 (igualdade)

***

### üîß M√âTODOS ALTERNATIVOS DE SOLU√á√ÉO

#### M√©todo 1: Bypass com GDB

```bash
# Configurar GDB para ignorar SIGILL
$ gdb behindthescenes
(gdb) handle SIGILL nostop noprint pass
Signal        Stop	Print	Pass to program	Description
SIGILL        No	No	Yes		Illegal instruction

# Colocar breakpoint em strncmp
(gdb) break strncmp
Breakpoint 1 at 0x1050

# Executar com senha teste
(gdb) run test_password
Breakpoint 1, 0x00007ffff7e9f3a0 in strncmp () from /lib/x86_64-linux-gnu/libc.so.6

# Examinar argumentos
(gdb) x/s $rdi
0x7fffffffe123:	"test_password"
(gdb) x/s $rsi  
0x55555555201b:	"Itz_0nLy_UD2"  # ‚Üê SENHA REVELADA!
```

#### M√©todo 2: Library Interposition

```bash
# Criar hook para strncmp
$ cat > hook_strncmp.c << 'EOF'
#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <dlfcn.h>

int strncmp(const char *s1, const char *s2, size_t n) {
    static int (*original_strncmp)(const char*, const char*, size_t) = NULL;
    if (!original_strncmp) {
        original_strncmp = dlsym(RTLD_NEXT, "strncmp");
    }
    
    printf("[HOOK] Comparing: '%s' vs '%s'\n", s1, s2);
    return original_strncmp(s1, s2, n);
}
EOF

# Compilar hook
$ gcc -shared -fPIC -o hook.so hook_strncmp.c -ldl

# Usar hook
$ LD_PRELOAD=./hook.so ./behindthescenes test
[HOOK] Comparing: 'test' vs 'Itz_0nLy_UD2'
# Senha revelada!
```

#### M√©todo 3: Binary Patching

```bash
# Localizar instru√ß√£o UD2
$ objdump -d behindthescenes | grep -n ud2
    0000000000001272:	0f 0b                	ud2

# Fazer backup
$ cp behindthescenes behindthescenes.backup

# Patch UD2 (0x0F 0x0B) para NOPs (0x90 0x90)
$ printf '\x90\x90' | dd of=behindthescenes bs=1 seek=$((0x1272)) count=2 conv=notrunc

# Testar bin√°rio patchado
$ ./behindthescenes test
# Agora deve executar sem anti-debug
```

***

### üìä AN√ÅLISE T√âCNICA PROFUNDA

#### Estrutura da T√©cnica Anti-Debug UD2

**Fluxo de Execu√ß√£o Normal:**

```
1. main() configura sigaction() para SIGILL
2. Handler definido: sigill_sigaction()  
3. Executa invalidInstructionException()
4. CPU encontra UD2 ‚Üí gera SIGILL
5. Kernel chama sigill_sigaction()
6. Handler incrementa RIP+2 (pula UD2)
7. Execu√ß√£o continua no c√≥digo oculto
8. C√≥digo oculto: strncmp(input, "Itz_0nLy_UD2")
9. Se igual: printf("> HTB{%s}", input)
10. Se diferente: return silencioso
```

**An√°lise das Estruturas:**

```c
// Estrutura sigaction (152 bytes)
struct sigaction {
    union {
        void (*sa_handler)(int);
        void (*sa_sigaction)(int, siginfo_t*, void*);
    } __sigaction_handler;           // +0x00 (8 bytes)
    sigset_t sa_mask;                // +0x08 (128 bytes)  
    int sa_flags;                    // +0x88 (4 bytes)
    void (*sa_restorer)(void);       // +0x90 (8 bytes)
};

// Context manipulation (offset 0xa8)
// ucontext_t.uc_mcontext.gregs[REG_RIP] = RIP + 2
```

#### Por Que a T√©cnica √© Eficaz

**Vantagens:**

‚úÖ **CPU-level protection**: Funciona abaixo das APIs\
‚úÖ **Minimal overhead**: Apenas 2 bytes (UD2)\
‚úÖ **Legitimate OS feature**: Signal handling √© normal\
‚úÖ **Code hiding**: An√°lise est√°tica para na UD2

**Desvantagens:**

‚ùå **Static analysis bypass**: Dados vis√≠veis na .rodata\
‚ùå **Emulation vulnerable**: Unicorn Engine ignora signals\
‚ùå **Patchable**: UD2 pode ser substitu√≠da por NOPs\
‚ùå **GDB configurable**: `handle SIGILL` bypassa prote√ß√£o

***

### üí° LI√á√ïES APRENDIDAS

#### T√©cnicas de Engenharia Reversa

**1. An√°lise de Imports √© Crucial**

```bash
sigaction + strncmp + printf = senha protegida por anti-debug
```

**2. Silent Failure √© Red Flag**

Programas normais d√£o feedback. Sil√™ncio indica prote√ß√£o.

**3. Data Hunting vs Code Analysis**

√Äs vezes os dados revelam mais que o c√≥digo.

**4. Multiple Attack Vectors**

Sempre ter planos B, C, D para diferentes cen√°rios.

#### Conceitos de Anti-Debug

**UD2 Technique Breakdown:**

* **Signal**: SIGILL (Illegal Instruction)
* **Handler**: Custom function to bypass
* **Mechanism**: RIP manipulation (+2 bytes)
* **Hiding**: Code after illegal instruction

**Detection Methods:**

```bash
# Static analysis
objdump -d binary | grep ud2
hexdump -C binary | grep "0f 0b"

# Dynamic analysis  
strace -e trace=signal binary
ltrace binary | grep sigaction
```

#### Red Team Applications

**Offensive Usage:**

```c
// Malware payload protection
void deploy_evil() {
    setup_sigill_handler();
    __asm__("ud2");
    // Hidden payload code here
    inject_shellcode();
}
```

**EDR Evasion:**

* Signal handling is legitimate behavior
* No suspicious API calls
* CPU-level protection vs software detection

***

### üõ†Ô∏è FERRAMENTAS UTILIZADAS

#### An√°lise Est√°tica:

```bash
file            # Identifica√ß√£o de tipo
strings         # Extra√ß√£o de strings
objdump         # Disassembly e an√°lise
readelf         # An√°lise de ELF headers/sections
hexdump         # An√°lise hexadecimal
nm              # S√≠mbolos
checksec        # Verifica√ß√£o de prote√ß√µes
```

#### An√°lise Din√¢mica:

```bash
strace          # System call tracing
ltrace          # Library call tracing  
gdb             # Debugging
```

#### Ferramentas Avan√ßadas:

```bash
ghidra          # Reverse engineering framework
python3         # Scripts de automa√ß√£o
gcc             # Compila√ß√£o de hooks
```

***

### üìà TIMELINE DA SOLU√á√ÉO

| **Tempo** | **A√ß√£o**               | **Descoberta**            |
| --------- | ---------------------- | ------------------------- |
| 0-10min   | Reconhecimento inicial | ELF64, imports suspeitos  |
| 10-20min  | Teste din√¢mico         | Falha silenciosa, SIGILL  |
| 20-30min  | An√°lise com Ghidra     | T√©cnica anti-debug UD2    |
| 30-40min  | Data hunting           | Strings na .rodata        |
| 40-45min  | Reconstitui√ß√£o         | Senha: Itz\_0nLy\_UD2     |
| 45min     | Teste final            | Flag: HTB{Itz\_0nLy\_UD2} |

**Total: \~45 minutos** para solu√ß√£o completa

***

### üéØ CONCLUS√ÉO

#### Flag Final

```
HTB{Itz_0nLy_UD2}
```

#### M√©todo de Solu√ß√£o

**An√°lise est√°tica da se√ß√£o .rodata** - demonstrando que nem sempre precisamos lutar contra as prote√ß√µes para venc√™-las.

#### Li√ß√£o Principal

> _"A melhor forma de vencer o anti-debug √†s vezes √© nunca debuggar. Os dados n√£o mentem, mesmo quando o c√≥digo tenta esconder."_

#### Skills Desenvolvidas

‚úÖ **Anti-debug recognition** (UD2 technique)\
‚úÖ **Static analysis mastery** (data hunting)\
‚úÖ **Signal handling understanding** (Linux internals)\
‚úÖ **Multiple attack vectors** (GDB, patching, hooks)\
‚úÖ **Problem-solving methodology** (lateral thinking)

***

### üîó REFER√äNCIAS

#### Documenta√ß√£o T√©cnica:

* [Intel UD2 Instruction Reference](https://www.intel.com/content/www/us/en/docs/ia-32-ia-64-developer-manual/)
* [Linux Signal Handling](https://man7.org/linux/man-pages/man7/signal.7.html)
* [sigaction(2) Manual](https://man7.org/linux/man-pages/man2/sigaction.2.html)

#### Recursos Educacionais:

* [Anti-Debug Techniques](https://anti-debug.checkpoint.com/)
* [Ghidra Documentation](https://ghidra-sre.org/CheatSheet.html)
* [ELF Format Specification](https://refspecs.linuxfoundation.org/elf/elf.pdf)

***

**Autor**: Ethical Hacker Underground\
**Plataforma**: HackTheBox\
**Desafio**: BehindTheScenes\
**Data**: 2024

_"Todo desafio √© uma oportunidade de aprender algo novo sobre a arte da engenharia reversa."_

***

### üìù COMANDOS RESUMIDOS

```bash
# Reconhecimento
file behindthescenes
strings behindthescenes
objdump -T behindthescenes

# An√°lise din√¢mica
./behindthescenes test
strace -e trace=signal ./behindthescenes test
ltrace ./behindthescenes test

# An√°lise est√°tica
ghidra  # Importar e analisar
readelf -x .rodata behindthescenes
objdump -s -j .rodata behindthescenes

# Descoberta da senha
python3 -c "print('Itz' + '_0n' + 'Ly_' + 'UD2')"

# Teste final
./behindthescenes Itz_0nLy_UD2
# Output: > HTB{Itz_0nLy_UD2}
```

**Flag: `HTB{Itz_0nLy_UD2}`** üèÜ

#### **üìä FASE 1: RECONNAISSANCE - "SNIFFING THE TARGET"**

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption><p>file behindthescenes</p></figcaption></figure>

{% code overflow="wrap" %}
```bash
$ file ./behindthescenes
behindthescenes: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=e60ae4c886619b869178148afd12d0a5428bfe18, for GNU/Linux 3.2.0, not stripped

$ strings behindthescenes | grep -v "lib\|GLIBC"
./challenge <password>
> HTB{%s}
strncmp
sigaction
printf
...

$ ./behindthescenes test
# Sil√™ncio total... CURIOSO, N√ÉO!?
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption><p>strings behindthescenes</p></figcaption></figure>

**üß† Red Flag Mental:** _"Programa que n√£o d√° erro nem feedback? Isso √© alguma prote√ß√£o, parceiro!"_

#### **üîç FASE 2: INTELLIGENCE GATHERING - "WHAT'S YOUR GAME?"**

<figure><img src="../../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

**Ghidra time!** Jogando o bin√°rio no Ghidra, primeira coisa que vejo:

<figure><img src="../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

```c
// Main function decompilada
sigaction(4,&local_a8,(sigaction *)0x0);  // Signal 4 = SIGILL
pcVar1 = (code *)invalidInstructionException(); // ‚Üê BINGO!
```

**üî• EUREKA MOMENT:** _"√â UD2 anti-debug! Est√£o usando instru√ß√£o ilegal pra esconder c√≥digo!"_

#### **üß† FASE 3: PATTERN RECOGNITION - "I SEE YOU"**

<figure><img src="../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

```c
void sigill_handler(context) {
    context->RIP += 2;  // Pula a instru√ß√£o UD2
}
```

**Mental Model:**

```
Setup handler ‚Üí Execute UD2 ‚Üí SIGILL triggered ‚Üí 
Handler skips UD2 ‚Üí HIDDEN CODE executes
```

**üéØ Hacker Logic:** _"Se tem strncmp nos imports, a senha t√° em algum lugar. Ser√°?"_

#### **üîç FASE 4: DATA HUNTING - "FOLLOW THE BREADCRUMBS"**

**Ca√ßando na .rodata section:**

```
0x102004: "./challenge <password>"  // String conhecida
0x10201b: 49 74 7A 00              // "Itz\0" ‚Üê SUSPICIOUS!
0x10201f: 5F 30 6E 00              // "_0n\0" ‚Üê PATTERN!
0x102023: 4C 79 5F 00              // "Ly_\0" ‚Üê CONTINUING!
0x102027: 55 44 32 00              // "UD2\0" ‚Üê JACKPOT!
```

**üî• Mental Explosion:** _"QUATRO STRINGS SEGUIDAS! Isso √© a senha em peda√ßos!"_

#### **üí° FASE 5: PUZZLE SOLVING - "CONNECT THE DOTS"**

```
Part 1: "Itz"
Part 2: "_0n"  
Part 3: "Ly_"
Part 4: "UD2"

Password = "Itz_0nLy_UD2"
```

**üé™ The Beautiful Irony:** _"A senha √© uma refer√™ncia √† pr√≥pria t√©cnica anti-debug! 'It's only UD2'"_

#### **‚ö° FASE 6: VALIDATION - "MOMENT OF TRUTH"**

```bash
$ ./behindthescenes Itz_0nLy_UD2
> HTB{Itz_0nLy_UD2}
```

**üéâ BOOM!** _Flag capturada sem nem encostar no anti-debug!_

***

### **üß† OS PILARES DA MENTALIDADE HACKER**

#### **1. NUNCA ACEITE O √ìBVIO**

* Programa silencioso = programa escondendo algo
* Imports revelam inten√ß√µes (sigaction + strncmp = senha protegida)
* Uso de Ghidra = bypass autom√°tico de prote√ß√µes

#### **2. PENSE COMO O ADVERS√ÅRIO**

* _"Se eu fosse esconder uma senha, onde colocaria?"_
* _"Como eu faria pra dificultar a vida do reverser?"_
* _"Que pistas eu deixaria sem querer?"_

#### **3. DADOS > C√ìDIGO**

* C√≥digo pode mentir, dados n√£o
* .rodata section √© ouro puro para senhas
* Padr√µes sequenciais s√£o sempre suspeitos

#### **4. LATERAL THINKING**

* N√£o lute contra a prote√ß√£o, GO AROUND
* Se n√£o pode debuggar, fa√ßa static analysis
* Use as ferramentas certas para o job certo

***

### **üéØ T√âCNICAS VISUAIS APLICADAS**

#### **Memory Layout Mental Model:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   .text         ‚îÇ ‚Üê UD2 anti-debug aqui
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   .rodata       ‚îÇ ‚Üê SENHA AQUI! üéØ
‚îÇ   0x102004      ‚îÇ   "./challenge <password>"
‚îÇ   0x10201b      ‚îÇ   "Itz\0"
‚îÇ   0x10201f      ‚îÇ   "_0n\0"  
‚îÇ   0x102023      ‚îÇ   "Ly_\0"
‚îÇ   0x102027      ‚îÇ   "UD2\0"
‚îÇ   0x10202b      ‚îÇ   "> HTB{%s}\n\0"
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### **Attack Vector Decision Tree:**

```
Binary Analysis
‚îú‚îÄ‚îÄ Dynamic? ‚Üí Anti-debug detected ‚Üí ‚ùå Hard path
‚îî‚îÄ‚îÄ Static? ‚Üí Data analysis ‚Üí ‚úÖ Easy win!
```

***

### **üî• LI√á√ïES**

#### **üé™ Golden Rules:**

1. **"Imports Don't Lie"** - `sigaction` = anti-debug, `strncmp` = password check
2. **"Data Tells Stories"** - Sequential strings em .rodata = senha fragmentada
3. **"Sometimes the backdoor is the front door"** - Ghidra bypassa anti-debug automaticamente
4. **"Pattern Recognition > Brute Force"** - 4 strings + format string = √≥bvio demais

#### **üõ†Ô∏è Ferramentas:**

```bash
# Reconnaissance
file, strings, hexdump, objdump

# Static Analysis  
Ghidra, IDA Pro, radare2, iaito (radare2 GUI)

# Dynamic Analysis (quando necess√°rio)
GDB, strace, ltrace

# Binary Manipulation
hexedit, dd, python struct
```

***

### **üìä IMPACT ASSESSMENT**

#### **Skills Desenvolvidas:**

* ‚úÖ **Anti-debug recognition** (UD2 technique)
* ‚úÖ **Static analysis mastery** (Ghidra power user)
* ‚úÖ **Pattern recognition** (data structure analysis)
* ‚úÖ **Lateral thinking** (bypass vs breakthrough)

#### **Knowledge Gained:**

* ‚úÖ **UD2 instruction behavior** and signal handling
* ‚úÖ **ELF structure** and section analysis
* ‚úÖ **CTF methodology** and writeup documentation
* ‚úÖ **Tool selection** for different scenarios

***

### **üî• CONCLUS√ÉO: THE HACKER WAY**

Esse challenge foi uma masterclass em **"work smarter, not harder"**. Enquanto outros hackers estariam quebrando a cabe√ßa tentando bypass o anti-debug, eu fui direto na jugular: **os dados**.

**A real li√ß√£o:** _"O melhor hack √© aquele que nem parece hack. √â s√≥ olhar no lugar certo."_

**üéØ Flag: `HTB{Itz_0nLy_UD2}`**

***

**Stay hungry, stay foolish, stay hacking! üî•**
